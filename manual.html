 <!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Swift Manual</title>
		<style>
			body {
				text-align: center;
			}

			#wrap {
				width: 900px;
				margin: 0 auto;
				text-align: left;
				padding: 20px;
			}
			pre {
				border-style: solid;
				border-width: 1px;
				border-color: #b3b3b3;
				padding: 10px;
				background-color: #e6e6e6;
			}
			h1, h2, h3, h4, h5 {
				color:#262626;
				font-family:"DejaVu Sans";}
			b {color: #004080}
			a {
				color: #cc0052;
				font-weight: bold;
				text-decoration: none;
			}
			dd {margin-bottom: 10px}
		</style>
	</head>

<body>
<div id="wrap">
	<h1>Swift Manual</h1>

	<h2>NAME</h2>
	<p>Swift - Relational Data Converter</p>

	<h2>SYNOPSIS</h2>
	<table>
		<tr>
			<td><b>swift-cli.py</b></td>
			<td>
				[<b>-h</b>] [<b>-ss</b> source_separator] [<b>-ta</b> target_attributes] [<b>-i</b>]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-mv</b> missing_value] [<b>-snh</b>] [<b>-tnh</b>] [<b>-t</b> [target]]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-ts</b> target_separator] [<b>-to</b> target_objects] [<b>-n</b> name]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-cls</b> classes] [<b>-sf</b> {csv,arff,dat,data,cxt,dtl}]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-tf</b> {csv,arff,dat,data,cxt,dtl}] [<b>-c</b> [rows_count]] [<b>-p</b> [rows_count]]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-sl</b> skipped_lines] [<b>-se</b>] [<b>-scs</b> source_cls_separator]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-tcs</b> target_cls_separator]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [source]
			</td>
		</tr>
		<tr>
			<td><b>swift.py</b></td>
			<td></td>
		</tr>
	</table>

	<h2>DESCRIPTION</h2>
	Swift - Relational Data Converter is a program for converting data files in six different <a href="#formats">formats</a>. All accepted formats are text and can be converted with each other, it means 36 possible conversions. Swift is focused on working with a table data where rows represent objects (instances) and columns their attributes (properties). Beside the data conversion, program supports also:
	<ul>
		<li><b>Filtering</b> - changing column order, changing columns occurrences, skipping columns and rows.</li>
		<li><b>Scaling</b>  - necessary for conversion multivalent formats (such as CSV, ARFF, C4.5) to bivalent formats (such as Burmeister, FIMI, DTL), but can be used for any converssion.</li>
		<li><b>Analyzing</b> - produces statistics of data.</li>
		<li><b>Preview</b> of data parts.</li>
	</ul>
	All operations work with data of any size, only limitation is a space of hard drive (not RAM).

	<p>
	Swift provides Command-line interface (swift-cli.py) and also Graphical user interface (swift.py), which is described in a seperate <a href="#gui">GUI Manual</a> section. For quick use without useless reading, go to <a href="#examples">examples</a> section which contains examples of common use cases.
	</p>
	<h3>Positional arguments</h3>
	<dl>
		<dt><b>source</b></dt>
		<dd>
		The name of the file (program reads and processes this file) in one of the supported <a href="#formats">format</a>. The <i>source</i> must ends with a valid format extension or the optional <i>--source_format</i> argument must be used. If the <i>source</i> is ommited or if it equals to "-", the program reads the input from the <i>stdin</i>.
		</dd>
	</dl>
	<h3>Optional arguments</h3>
	<dl>
		<dt><b>-h, --help</b></dt>
		<dd>Print the help message to the <i>stdout</i> and exit.</dd>

		<dt><b>-t</b> target, <b>--target</b> target</dt>
		<dd>
		The name of the file (program writes to this file) in one of the supported <a href="#formats">format</a>. The <i>--target</i> must ends with a valid format extension or the optional <i>--target_format</i> argument must be used. If the <i>--target</i> is omitted or if it equals to "-", the program writes the input to the <i>stdout</i>.
		</dd>

		<dt><b>-ta </b>target_attributes, <b>--target_attributes</b> target_attributes</dt>
		<dd>
		The list of formulas seperated by ";",
		<pre><code>formulas ::= formula | (formula ";" formulas)</code></pre>
		where formula is the definition of attribute in the target file. The formula is of the form:
		<pre><code>formula ::= (new-names "=")? old-names ((":" type ("[" scale "]")?) | "[]")?</code></pre>
		<u>The first part</u> of the formula:
		<pre><code>(new-names "=")? old-names</code></pre>
		where new-names and old-names are the lists of names seperated by ",":
		<pre><code>names ::= name | (name "," names)</code></pre>
		where name is the word or the interval:
		<pre><code>name ::= \w+ | ((\d+)? "-" (\d+)?) | "*"</code></pre>
		has the following meaning: old-names refer to attributes in the source file by using their names (if are available) or indexes. New-names define new names of attributes used in the target file. If new-names are omitted, attributes in the target file have the same names as in the source file. New-names and old-names must have the same length, otherwise error is produced.
		<p>
		The interval determines range of indexes. If the lower bound is omitted, indexes range is from zero to upper bound. If the upper bound is omitted, indexes range is from lower bound to the maximum index of attribute in the target file. If both upper and lower bounds are omitted, indexes range is from zero to the maximum index of the attribute in the source file (for this case has been added alis "*", which has the same meaning as "-").
		</p>
		Examples (seven attributes in source file):
		<table>
			<tr><td>
			<code>4-6 produces: 4, 5, 6</code>
			</td></tr>

			<tr><td>
			<code>-5 produces: 0, 1, 2, 3, 4, 5</code>
			</td></tr>

			<tr><td>
			<code>4- produces: 4, 5, 6, 7</code>
			</td></tr>

			<tr><td>
			<code>- produces: 0, 1, 2, 3, 4, 5, 6, 7</code>
			</td></tr>

			<tr><td>
			<code>* produces: 0, 1, 2, 3, 4, 5, 6, 7</code>
			</td></tr>
		</table>
		<p><u>The second optional part</u> of the formula</p>
		<pre><code>((":" type ("[" scale "]")?) | "[]")?</code></pre>
		is composed of the attribute type,
		<pre><code>type ::= "n" | "e" | "s" | ("d" ("/" date_format)?)
date_format ::= "F="? "'" .+ "'"</code></pre>
		where characters are aliases of data types:
		<ul>
			<li>n = numeric - all real numbers</li>
			<li>e = enumeration - finite set of named values</li>
			<li>s = string - word</li>
			<li>d = date - the default date format is ISO-8601 which combines date and time: YYYY-MM-DDThh:mm:ss. For using different date formats must be used <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">python format codes</a>,</li>
		</ul>
		<p>optional definition of the scale and the <a href="#unpack">binary unpacking</a>.</p>
		<pre><code>scale ::= num_scale | enum_scale | str_scale | date_scale | bin_vals</code></pre>
		The scale is an expression which is evaluated with a value of the attribute. Result of evaluation is True or False represented as 0 and 1.
		<p>In the <i>numeric scale</i>,</p>
		<pre><code>num_scale ::= (var op num_val) | (num_val op var) | (num_val op var op num_val)</code></pre>
		the numeric value is of the form:
		<pre><code>num_val ::= int ("." number?)? ("e" int)?
int ::= ("+" | "-")? \d+</code></pre>
		Examples of numeric value: <code>5, -10, +47, 2.46, -2.31, +98.31, -78.4e-48, 3e8</code>
		<pre><code>var ::= [a-z_]+</code></pre>
		Variables (the form above) represent the current value of the scale evaluation and operations have the same meaning as in many programing languages such as C or Python.
		<pre><code>op ::= "<" | ">" | "<=" | ">=" | "==" | "!="</code></pre>
		Examples of numeric scales (variable is x): <code>x!=10.3, -5<=x<=10, 50==x </code>
		<p>The <i>enumeration scale</i></p>
		<pre><code>enum_scale ::= "'" \w+ "'"</code></pre>
		is the one of the value of enumeration, which must be quoted. If the value of the attribute is the exactly same as the scale, the result of the scaling is True, otherwise False.
		<p>The <i>string scale</i></p>
		<pre><code>str_scale ::= "'" .+ "'"</code></pre>
		is a quoted <a href="https://docs.python.org/2/library/re.html"> python regular expression</a>. If the regular expression matches any substring of the scaled value, result of scaling is True, otherwise False.
		<p>Example of the string scale: <code>"foo[+-*]*bar"</code>, which matches "hellfoobar", "foo--barxyz" ... but doesn't match "foo/bar" ...</p>
		<p>The <i>date scale</i></p>
		<pre><code>date_scale ::= ((var op date_val) | (date_val op var) | (date_val op var op date_val))</code></pre>
		is the exactly same expression as numeric scale, but values must be dates in valid date format.
		<p><i>Binary values</i></p>
		<pre><code>bin_vals ::= ("0="? "'" .* "'" ",")? "1="? "'" .+ "'"</code></pre>
		allow to define new <i>binary values</i> for some bivalent attribute. The default values are 1 (True) and 0 (False). This can be useful for the conversion from multivalent format (which contains bivalent attribute, but values are different from 0 and 1) to bivalent format, without useless scaling (because values are bivalent already). Note that, this way is semantically the same as using enumeration for bivalent attribute, but use of <i>binary values</i> is prefered because is more time-efficient.
		<p id="unpack">
		The alternative to the scale is the <i>binary unpacking</i> (the total binarization) of the attribute, which can be used by "[]", writed just behind the names. This creates new attribute for every single value of the old attribute. Every new attribute is ot type enumeration with the scale: value. The order of new attributes is the same as the order of values in template attribute. If <i>binary unpacking</i> is used for more attributes, for example for two attribites, then every new attribute of the first old attribute has lower index then any of new attribute of the second old attribute.
		</p>
		<p>Example - <i>binary unpacking</i> of two attributes:</p>
		<table>
			<tr>
				<td>in
<pre>
a x
b y
b z
a x
c y
</pre>
				</td>
				<td>out
<pre>
1 0 0  1 0 0
0 1 0  0 1 0
0 1 0  0 0 1
1 0 0  1 0 0
0 0 1  0 1 0
</pre>
				</td>
			</tr>
		</table>
		<p>Complete grammar of the <i>--target_attributes</i> argument:</p>
		<pre><code>formulas ::= formula | (formula ";" formulas)
formula ::= (names "=")? names ((":" type ("[" scale "]")?) | "[]")?
names ::= name | (name "," names)
type ::= "n" | "e" | "s" | ("d" ("/" date_format)?)
scale ::= num_scale | enum_scale | str_scale | date_scale | bin_vals
name ::= \w+ | ((\d+)? "-" (\d+)?) | "*"
date_format ::= "F="? "'" .+ "'"
num_scale ::= (var op num_val) | (num_val op var) |
              (num_val op var op num_val)
enum_scale ::= "'" \w+ "'"
str_scale ::= "'" .+ "'"
date_scale ::= ((var op date_val) | (date_val op var) |
                (date_val op var op date_val))
bin_vals ::= ("0="? "'" .* "'" ",")? "1="? "'" .+ "'"
var ::= [a-zA-Z_]+
op ::= "<" | ">" | "<=" | ">=" | "==" | "!="
date_val ::= "'" .+ "'"
num_val ::= int ("." number?)? ("e" int)?
int ::= ("+" | "-")? \d+</code></pre>
		If the <i>--target_attributes</i> argument is omitted, all attributes readed from the <i>source</i> are processed.
		</dd>

		<dt><b>-c</b> [rows_count], <b>--convert</b> [rows_count]</dt>
		<dd>
			Converts the <i>source</i> to the <i>--target</i>. The optional argument rows_count defines how many rows of data should be processed.
		</dd>

		<dt><b>-p</b> [rows_count], <b>--preview</b> [rows_count]</dt>
		<dd>Prints desired count of rows from the <i>source</i> table data in to the <i>stdout</i>. The default amount of printed rows is 20, but this value can be changed by using the optional argument rows_count.
		</dd>

		<dt><b>-i, --info</b></dt>
		<dd>
		Prints the statistics of the <i>source</i> and for its each processed attribute. Statistics is of the form:
<pre>Relation name:
Objects count:
Attributes count:
====================

name:
index:
type: string/enumeration
values appearance:
    value: occurences-count/total-count = %
	.
	.
	.

name:
index:
type: numeric/date
max: , min:
values appearance:
    value: occurences-count/total-count = %
	.
	.
	.

.
.
.</pre>
		The <i>--info</i> may be used as single action (the statistics is printed to the <i>stdout</i>) or in parallel with the conversion (if <i>--target</i> is <i>stdout</i>, the new file named same as the <i>source</i>, but with extension .info is produced). The usage <i>--info</i> in parallel with conversion is useful for the saving time if both actions are required.
		</dd>

		<dt><b>-sf</b> {csv,arff,dat,data,cxt,dtl},
			<b>--source_format</b> {csv,arff,dat,data,cxt,dtl}</dt>
		<dd>
		Specifies the <i>source</i> format using the extension. If the <i>source</i> doesn't have the extension, the <i>--source_format</i> is required. If the <i>source</i> has the extension and <i>--source_format</i> is also used, the <i>--source_format</i> overwrites the <i>source</i> extension.
		</dd>

		<dt><b>-tf</b> {csv,arff,dat,data,cxt,dtl},
			<b>--target_format</b> {csv,arff,dat,data,cxt,dtl}</dt>
		<dd>
		Specifies the <i>--target</i> format using the extension. If the <i>--target</i> doesn't have the extension, the <i>--target_format</i> is required. If the <i>--target</i> has the extension and <i>--target_format</i> is also used, the <i>--target_format</i> overwrites the <i>--target</i> extension.
		</dd>

		<dt><b>-cls</b> classes,
			<b>--classes</b> classes
		</dt>
		<dd>
		Selects attributes from the <i>source</i>, which will be used as classes in the <i>--target</i>. It can be specified using the interval of attribute indexes, or using names of attributes, or both in combination. <i>--classes</i> is of the form:
		<pre><code>classes ::= element | (element "," classes)
element = interval | key
interval ::= ((\d+)? "-" (\d+)?)
key = \w+</code></pre>

		This argument is relevant only in the case, when the <i>--target</i> format is <a href="#data">C4.5</a> or <a href="#dtl">DTL</a>.
		</dd>

		<dt><b>-ss</b> source_separator,
			<b>--source_separator</b> source_separator
		</dt>
		<dd>
		Specifies the separator of attributes in the <i>source</i> (it affects only the current action). <i>--source_separator</i> must be specified, when the separator used in the <i>source</i> is a different from a default file format separator.
		</dd>

		<dt><b>-ts</b> target_separator,
			<b>--target_separator</b> target_separator
		</dt>
		<dd>
		Specifies the separator of attributes in the <i>--target</i> (it affects only the current action). Attributes in the <i>--target</i> will be seperated with this new value.
		</dd>

		<dt><b>-scs</b> source_classes_separator,
			<b>--source_cls_separator</b> source_classes_separator
		</dt>
		<dd>
		Specifies the separator of attributes and classes in the <i>source</i> (it affects only the current action). <i>--source_cls_separator</i> must be specified, when the classes/attributes separator used in the <i>source</i> is a different from a default file format classes/attributes separator. This argument is relevant only in the case, when the <i>source</i> format is <a href="#dtl">DTL</a>.
		</dd>

		<dt><b>-tcs</b> target_classes_separator,
			<b>--target_cls_separator</b> target_classes_separator
		</dt>
		<dd>
		Specifies the  separator of attributes and classes in the <i>--target</i> (it affects only the current action). Attributes and classes in the <i>--target</i> will be seperated with this new value. This argument is relevant only in the case, when the <i>--target</i> format is <a href="#dtl">DTL</a>.
		</dd>

		<dt><b>-sl</b> skip_lines,
			<b>--skip_lines</b> skip_lines
		</dt>
		<dd>
		The interval of the form
		<pre><code>interval ::= (\d+)? "-" (\d+)?</code></pre>
		specifies <i>source</i> indexes of lines, which will be skipped in any action.
		</dd>

		<dt><b>-se</b>,
			<b>--skip_errors</b>
		</dt>
		<dd>
		Erros produced by invalid lines in the <i>source</i> are skipped. Program continues and skipped erros are printed to the <i>stderr</i>.
		</dd>

		<dt><b>-n</b> name,
			<b>--name</b> name
		</dt>
		<dd>
		Specifies the new name of relation (data).
		</dd>

		<dt><b>-mv</b> missing_value,
			<b>--missing_value</b> missing_value
		</dt>
		<dd>
		Specifies the value, which will be interpreted as an undefined value (None/NULL). The result of scaling the <i>--missing_value</i> is always False (0).
		</dd>

		<dt><b>-o</b> objects,
			<b>--objects</b> objects
		</dt>
		<dd>
		The list of object names seperated by comma:
		<pre><code>objects ::= name | (name "," objects)</code></pre>
		This argument is relevant only in the case, when <i>--target</i> format is <a href="#cxt">Burmeister</a>. If <i>--objects</i> is ommited, indexes of objects are used.
		</dd>

		<dt><b>-snh</b> source_no_header,
			<b>--source_no_header</b> source_no_header
		</dt>
		<dd>
		The first row in the <a href="#csv">CSV</a>  <i>source</i> is interpreted as a object (not header).
		</dd>

		<dt><b>-tnh</b> target_no_header,
			<b>--target_no_header</b> target_no_header
		</dt>
		<dd>
		The <a href="#csv">CSV</a> <i>--target</i> will have the object on the first line.
		</dd>

	</dl>


	<h3 id="">Errors</h3>
	The following errors in the list are of the form:
<pre><code>error_code: error_name
	error_description
</code></pre>
which are produced by the program. When an error is raised, program ends and returns the error code.
	<dl>
		<dt><b>1</b>: Swift Unknown Error</dt>
		<dd>If you get this error, please <a href="#bugs">report</a> this bug with details printed below the error message. Thank you.</dd>

		<dt><b>2</b>: Argument Error</dt>
		<dd>Some of required arguments are missing or aren't specified correctly.</dd>

		<dt><b>3</b>: ARFF Header Error</dt>
		<dd>The syntax error in the header of the ARFF <i>source</i> file.</dd>

		<dt><b>4</b>: DATA Header Error</dt>
		<dd>The syntax error in the header of the DATA <i>source</i> file.</dd>

		<dt><b>5</b>: CSV Header Error</dt>
		<dd>The syntax error in the header of the CSV <i>source</i> file.</dd>

		<dt><b>6</b>: DAT header Error</dt>
		<dd>The syntax error in the header of the DAT <i>source</i> file.</dd>

		<dt><b>7</b>: CXT Header Error</dt>
		<dd>The syntax error in the header of the CXT <i>source</i> file.</dd>

		<dt><b>8</b>: ARFF Line Error</dt>
		<dd>The syntax error in the line of the ARFF <i>source</i> file.</dd>

		<dt><b>9</b>: DATA Line Error</dt>
		<dd>The syntax error in the line of the DATA <i>source</i> file.</dd>

		<dt><b>10</b>: CSV Line Error</dt>
		<dd>The syntax error in the line of the CSV <i>source</i> file.</dd>

		<dt><b>11</b>: DAT Line Error</dt>
		<dd>The syntax error in the line of the DAT <i>source</i> file.</dd>

		<dt><b>12</b>: CXT Line Error</dt>
		<dd>The syntax error in the line of the CXT <i>source</i> file.</dd>

		<dt><b>13</b>: DTL Line Error</dt>
		<dd>The syntax error in the line of the DTL <i>source</i> file.</dd>

		<dt><b>14</b>: Formula Error</dt>
		<dd>The syntax error in some formula of the <i>--target_attributes</i> argument.</dd>

		<dt><b>15</b>: Formula Names Error</dt>
		<dd>The count of new names and the count of old names aren't equal.</dd>

		<dt><b>16</b>: Sequence Error</dt>
		<dd>The syntax error in the sequance (interval).</dd>

		<dt><b>17</b>: DATE Value Error</dt>
		<dd>The invalid value of the date attribute.</dd>

		<dt><b>18</b>: NUMERIC Value Error</dt>
		<dd>The invalid value of the numeric attribute.</dd>

		<dt><b>19</b>: STRING Value Error</dt>
		<dd>The invalid value of the string attribute.</dd>

		<dt><b>20</b>: NOMINAL Value Error</dt>
		<dd>The invalid value of the nominal (enumeration) attribute.</dd>

		<dt><b>21</b>: DATE Error</dt>
		<dd>The invalid syntax of the date.</dd>

		<dt><b>22</b>: Formula Date Value/Format Error</dt>
		<dd>The value and the format of the date doesn't match.</dd>

		<dt><b>23</b>: Formula Regular Expression Error</dt>
		<dd>The invalid regular expression in the formula.</dd>

		<dt><b>24</b>: Formula Attribute Key Error</dt>
		<dd>The given key of the attribute doesn't exists.</dd>

		<dt><b>25</b>: Keyboard Interrupt Error</dt>
		<dd></dd>

		<dt><b>26</b>: Bivalent Error</dt>
		<dd>The invalid bivalent value in data.</dd>

		<dt><b>27</b>: Broken Pipe Error</dt>
		<dd></dd>

		<dt><b>28</b>: Names File Error</dt>
		<dd>Files: .names and .data (C4.5 format) aren't in the same directory.</dd>

		<dt><b>29</b>: DTL Header Error</dt>
		<dd>The syntax error in the header of the DTL <i>source</i> file.</dd>

	</dl>


	<h2 id="formats">SUPPORTED FORMATS</h2>
		Swift supports following six formats:
		<h3 id="csv">Comma-separated values (.csv)</h3>
			The description of the format with examples can be found <a href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.
			<p><i>Notes: </i>The attribute separator inside the value must be always escaped by the backslash.</p>

		<h3 id="arff">Attribute-Relation File Format (.arff)</h3>
			The description of the format with examples can be found <a href="http://weka.wikispaces.com/ARFF+%28stable+version%29">here</a>.
			<p><i>Notes:</i> The optional date format for the date attribute in the header, must be specified with python <a href="https://docs.python.org/3.5/library/datetime.html#strftime-and-strptime-behavior">format codes</a> (not in the Java SimpleDateFormat as specified in the official documentation).</p>
			Example:
<pre><code>@relation birthdays
@attribute birthday date %Y-%m-%d
@data
1990-04-23
1993-12-03
1989-03-31</code></pre>

<p>When converting from the arff file with some relational attributes to some other format, relational attributes are linearized (using dot notation, see example).</p>
Example:
<pre><code>@attribute humidity relational
    @attribute absolute relational
        @attribute day numeric
        @attribute nigth numeric
    @end absolute
@end humidity</code></pre>

The relational attribute humidity (above) will be converted to attributes (e.g for csv target):
<pre><code>humidity.absolute.day, humidity.absolute.night</code></pre>

		<h3 id="data">C4.5 File Format (.data .names)</h3>
		The description of the format with examples can be found <a href="http://www.cs.washington.edu/dm/vfml/appendixes/c45.htm">here</a>.
		<p><i>Notes: </i>With the class, must be worked exactly the same as with the attributes at any conversion (class can be scaled, total binarized, ...). The key used in the <i>--target_attributes</i> is the class index or the name: "class".</p>

		<h3 id="cxt">Burmeister (.cxt)</h3>
		The description of the format with examples can be found <a href="http://www.upriss.org.uk/fca/fcafileformats.html#Burmeister">here</a>.

		<h3 id="dat">FIMI File Format (.dat)</h3>
		The description of the format with examples can be found <a href="http://fcalgs.sourceforge.net/format.html">here</a>.
		<p><i>Notes: </i>The blank lines are readed (from FIMI source) as objects, with all attributes of the value 0 (False). And conversely objects with all attributes of the value 0 (False), are writed (to FIMI target) as blank lines. It differs from the official format documentation, which ignore blank lines and objects with all attributes of value 0.</p>

		<h3 id="dtl">DTL File Format (.dtl)</h3>
		<p>This format is very similiar to FIMI, but it supports specification of classes for each object. The file consists of rows of the form:
		<pre><code>attributes "|" classes</code></pre>
		where attributes part is exactly the same as attributes in the FIMI format (values are indexes of attributes with value 1) and "|" separates attributes and classes. The classes part consists of various values, separated with the same separator as attributes are.</p>
		Example (<code>class1={a,b}, class2={aa,bb}</code>):
<pre><code>0 1 2 3 4|a bb
1 2 3 4|a aa
2 3 4|b bb
3 4|a bb
4|b bb</code></pre>

		<p>With classes must be worked exactly the same as with the attributes at any conversion (class can be scaled, total binarized, ...). The key used in the <i>--target_attributes</i> is the class index or the name: "class1", "class2"... .</p>

	<h2 id="examples">EXAMPLES</h2>
	<h3>Sample data</h3>
	<dl>
		<dt>CSV - example.csv</dt>
		<dd>
<pre><code>name,   birth_date, credits, study, sex
George, 1991-06-13, 54,      true,  man
Monica, 1990-04-23, 98,      false, woman
Mia,    ?,          87,      true,  woman
John,   1989-11-11, 91,      true,  man</code></pre>
		</dd>

		<dt>DTL - example.dtl</dt>
		<dd>
<pre><code>0 1 2 3 4|a bb
1 2 3 4|a aa
2 3 4|b bb
3 4|a bb
4|b bb</code></pre>
		</dd>

		<dt>DAT - example.dat</dt>
		<dd>
<pre><code>0
1
2
3
4</code></pre>
		</dd>

		<dt>C4.5</dt>
		<dd>
		example.names
<pre><code>foo, bar.
age: cotinuous.
job: teacher, pilot, doctor.
work: discrete 2.
sport: ignore.</code></pre>
example.data
<pre><code>44, doctor,  1, foo
30, teacher, 0, bar
35, ?,       1, foo
31, pilot,   0, foo
</code></pre>
		</dd>

	</dl>
	<h3>Convert</h3>
	<dl>

		<h4>Simple Conversion</h4>
	<dt>DTL to CSV</dt>
	<dd>
		<pre><code>swift-cli.py example.dtl -t result.csv</code></pre>
		result.csv
<pre><code>
0,1,2,3,4,class1,class2
1,1,1,1,1,a,bb
0,1,1,1,1,a,aa
0,0,1,1,1,b,bb
0,0,0,1,1,a,bb
0,0,0,0,1,b,bb
</code></pre>
	<i>Next possible conversions:</i>
	<ul>
		<li>CSV to CSV</li>
		<li>ARFF to ARFF</li>
		<li>ARFF to CSV</li>
		<li>DATA to CSV</li>
		<li>DATA to ARFF</li>
		<li>DAT to DAT</li>
		<li>DAT to CSV</li>
		<li>DAT to ARFF</li>
		<li>CXT to CXT</li>
		<li>CXT to CSV</li>
		<li>CXT to DAT</li>
		<li>CXT to ARFF</li>
		<li>DTL to ARFF</li>
	</ul>

	</dd>

		<h4>Types specification</h4>
		<dt>CSV to ARFF</dt>
		<dd>
		<pre><code>swift-cli.py example.csv -t result.arff -mv '?' -ta "name:s; 1:d/'%Y-%m-%d'; credits:n; work,gender=3,4:e" -n people</code></pre>
		result.arff
<pre><code>@relation people

@attribute name string
@attribute birth_date date %Y-%m-%d
@attribute credits numeric
@attribute work { true,false }
@attribute gender { man,woman }

@data
George,1991-06-13,54,true,man
Monica,1990-04-23,98,false,woman
Mia,?,87,true,woman
John,1989-11-11,91,true,man</pre></code>
		</dd>

		<h4>Classes specification</h4>
		<dt>CSV to DATA</dt>
		<dd>
		<pre><code>swift-cli.py example.csv -t result.data -mv '?' -ta "name:s; 1:d/'%Y-%m-%d'; credits:n; 3,4:e" -n people -cls sex</code></pre>

		result.names
<pre><code>man,woman.
name: discrete n.
birth_date: discrete n.
credits: continuous.
study: true,false.
sex: man,woman.</code></pre>
		result.data
<pre><code>George,1991-06-13,54,true,man,man
Monica,1990-04-23,98,false,woman,woman
Mia,?,87,true,woman,woman
John,1989-11-11,91,true,man,man</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to DATA</li>
		<li>DATA to DATA</li>
		<li>DAT to DTL</li>
		<li>DAT to DATA</li>
		<li>CXT to DATA</li>
		<li>CXT to DTL</li>
		<li>DTL to DTL</li>
		<li>DTL to DATA</li>
	</ul>

		</dd>


	<h4>Object names and attribute names specification</h4>
	<dt>DAT to CXT</dt>
	<dd>

	<pre><code>swift-cli.py example.dat -t result.cxt -o foo,bar,foobar,barfoo -ta 'a=0;b=1;c=2;d=3'</code></pre>
	result.cxt
<pre><code>B

4
4
foo
bar
foobar
barfoo
a
b
c
d
X...
.X..
..X.
...X</code></pre>

	<h4>Scale</h4>
	<dt>CSV to DAT</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -mv '?' -t result.dat -ta "name:s['M.+a']; birth_date:d/'%Y-%m-%d'[x&gt='1991-01-01'];
             credits:n[50&lt=x&lt=90]; study:e['true']; sex:e['man']"</code></pre>
result.dat
<pre><code>1 2 3 4
0
0 2 3
3 4</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to DAT</li>
		<li>DATA to DAT</li>
		<li>DTL to DAT</li>
	</ul>
	</dd>

	<h4>Scale and object names specification</h4>
	<dt>CSV to CXT</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -mv '?' -t result.cxt -o s001,s002,s003,s004 -ta "name:s['M.+a'];
	     birth_date:d/'%Y-%m-%d'[x&gt='1991-01-01']; credits:n[50&lt=x&lt=90]; study:e['true']; sex:e['man']"</code></pre>
	result.cxt

<pre><code>B

4
5
s001
s002
s003
s004
name
birth_date
credits
study
sex
.XXXX
X....
X.XX.
...XX</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to CXT</li>
		<li>DATA to CXT</li>
	</ul>
	</dd>

	<h4>Scale and classes specification</h4>
	<dt>CSV to DTL</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -mv '?' -t result.dtl -cls 3,4 -ta "name:s['M.+a'];
	     birth_date:d/'%Y-%m-%d'[x&gt='1991-01-01']; credits:n[50&lt=x&lt=90]; study:e['true']; sex:e['man']"</code></pre>
	result.dtl
<pre><code>1 2 3 4|true man
0|false woman
0 2 3|true woman
3 4|true man</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to DTL</li>
		<li>DATA to DTL</li>
	</ul>

	</dd>

	<h4>Scale, object names and attribute names specification</h4>
	<dt>DTL to CXT</dt>
	<dd>
	<pre><code>swift-cli.py example.dtl -t result.cxt -ta "b1,b2,b3,b4,b5=0-4;class1:e['b'];class2:e['bb']" -o a,b,c,d,e</code></pre>
	<pre><code>B

5
7
a
b
c
d
e
b1
b2
b3
b4
b5
class1
class2
XXXXX.X
.XXXX..
..XXXXX
...XX.X
....XXX</code></pre>
	</dd>

	</dl>
	<h3>Binary Unpacking</h3>
	<h3>Filter</h3>
	<h3>Info</h3>
	<h3>Preview</h3>

	<h2 id="gui">GUI MANUAL</h2>
	<h2 id="installation">INSTALLATION</h2>
	<h3>Requirements</h3>
	<h2 id="bugs">REPORTING BUGS</h2>
	If you find a bug, please create an issue with a description on <a href="https://github.com/gnovis/swift/issues">https://github.com/gnovis/swift/issues</a>.
	<h2 id="contribute">CONTRIBUTING</h2>
	You are welcome to participate in development of this project. Join us on <a href="https://github.com/gnovis/swift">github</a>.
	<h2 id="authors">AUTHORS</h2>
	Jan Novacek (novacekj5@gmail.com), Jan Outrata
	<h2 id="licence">LICENSE</h2>
	Swift  is  distributed  under the  GNU GPL v3 - <a href="http://www.gnu.org/licenses/gpl-3.0.html">http://www.gnu.org/licenses/gpl-3.0.html</a>.
	<h2 id="download">DOWNLOAD</h2>
	This program can be obtined from <a href="https://github.com/gnovis/swift">https://github.com/gnovis/swift</a> or by the direct <a href="https://github.com/gnovis/swift/zipball/master/">link</a>.
</div>
</body>
</html>
