 <!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Swift - Main manual</title>
		<link rel="stylesheet" href="./style.css" type="text/css"/>
		<link rel="shortcut icon" href='./img/swift_icon.ico'>
	</head>

<body>

<div id="header">
	<div id="header_content">
		<a href="index.html"><img id="icon"src="./img/swift_icon.svg"></a>
		<span>Swift - Relational Data Converter</span>
	</div>
</div>

<div id="content">

	<h1>Main manual</h1>

<ul>
<li><a href="#name">1 NAME</a></li>
<li><a href="#synopsis">2 SYNOPSIS</a></li>
<li><a href="#description">3 DESCRIPTION</a></li>
<ul>
<li><a href="#pos_args">3.1 Positional arguments</a></li>
<li><a href="#opt_args">3.2 Optional arguments</a></li>
<li><a href="#errors">3.3 Errors</a></li>
</ul>
<li><a href="#formats">4 SUPPORTED FORMATS</a></li>
<ul>
<li><a href="#csv">4.1 Comma-separated values (.csv)</a></li>
<li><a href="#arff">4.2 Attribute-Relation File Format (.arff)</a></li>
<li><a href="#data">4.3 C4.5 File Format (.data .names)</a></li>
<li><a href="#cxt">4.4 Burmeister (.cxt)</a></li>
<li><a href="#dat">4.5 FIMI File Format (.dat)</a></li>
<li><a href="#dtl">4.6 DTL File Format (.dtl)</a></li>
</ul>
<li><a href="#examples">5 EXAMPLES</a></li>
<ul>
<li><a href="#sample_data">5.1 Sample data</a></li>
<li><a href="#convert">5.2 Convert</a></li>
<ul>
<li><a href="#simple">5.2.1 Simple Conversion</a></li>
<li><a href="#type_spec">5.2.2 Types specification</a></li>
<li><a href="#cls_spec">5.2.3 Classes specification</a></li>
<li><a href="#types_cls_spec">5.2.4 Types, classes specification</a></li>
<li><a href="#obj_atrr_spec">5.2.5 Object names and attribute names specification</a></li>
<li><a href="#scale">5.2.6 Scale</a></li>
<li><a href="#scale_obj_spec">5.2.7 Scale and object names specification</a></li>
<li><a href="#scale_cls_spec">5.2.8 Scale and classes specification</a></li>
<li><a href="#scale_obj_attr_spec">5.2.9 Scale, object names and attribute names specification</a></li>
</ul>
<li><a href="#bin_unpack">5.3 Binary Unpacking</a></li>
<li><a href="#filter">5.4 Filter</a></li>
<li><a href="#info">5.5 Info</a></li>
<li><a href="#preview">5.6 Preview</a></li>
</ul>
<li><a href="#installation">6 INSTALLATION</a></li>
<ul>
<li><a href="#requirements">6.1 Requirements</a></li>
<li><a href="#download">6.2 Download</a></li>
<li><a href="#unpackzip">6.3 Unpack</a></li>
<li><a href="#finish">6.4 Finish</a></li>
</ul>
<li><a href="#bugs">7 REPORTING BUGS</a></li>
<li><a href="#contribute">8 CONTRIBUTING</a></li>
<li><a href="#authors">9 AUTHORS</a></li>
<ul>
<li><a href="#proofreaders">9.1 Proofreaders</a></li>
</ul>
<li><a href="#website">10 WEBSITE</a></li>
<li><a href="#licence">11 LICENSE</a></li>
</ul>

	<h2 id="name">NAME</h2>
	<p>Swift - Relational Data Converter</p>

	<h2 id="synopsis">SYNOPSIS</h2>
	<table>
		<tr>
			<td><b>swift-cli.py</b></td>
			<td>
				[<b>-h</b>] [<b>-ss</b> source_separator] [<b>-ta</b> target_attributes] [<b>-i</b>]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-mv</b> missing_value] [<b>-snh</b>] [<b>-tnh</b>] [<b>-t</b> [target]]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-ts</b> target_separator] [<b>-to</b> target_objects] [<b>-n</b> name]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-cls</b> classes] [<b>-sf</b> {csv,arff,dat,data,cxt,dtl}]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-tf</b> {csv,arff,dat,data,cxt,dtl}] [<b>-c</b> [rows_count]] [<b>-p</b> [rows_count]]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-sl</b> skipped_lines] [<b>-se</b>] [<b>-scs</b> source_cls_separator]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-tcs</b> target_cls_separator]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [source]
			</td>
		</tr>
		<tr>
			<td><b>swift.py</b></td>
			<td></td>
		</tr>
	</table>

	<h2 id="description">DESCRIPTION</h2>
	Swift - Relational Data Converter is a program for converting data files in six different <a href="#formats">formats</a>. All accepted formats are text and can be converted with each other, it means 36 possible conversions. Swift is focused on working with a table data where rows represent objects (instances) and columns their attributes (properties). Beside the data conversion, program supports also:
	<ul>
		<li><b>Filtering</b> - changing column order, changing column occurrences, skipping columns and rows.</li>
		<li><b>Scaling</b>  - necessary for conversion multivalent formats (such as CSV, ARFF, DATA) to bivalent formats (such as CXT, DAT, DTL), but can be used for any conversion.</li>
		<li><b>Analyzing</b> - produces statistics of data.</li>
		<li><b>Preview</b> of data parts.</li>
	</ul>
	All operations work with data of any size, only limitation is a space of hard drive (not RAM).

	<p>
	Swift provides Command-line interface (swift-cli.py) and also Graphical user interface (swift.py), which is described in a separate <a href="guimanual.html">GUI Manual</a>. For a quick usage without useless reading, go to <a href="#examples">examples</a> section, which contains examples of common use cases.
	</p>
	<h3 id="pos_args">Positional arguments</h3>
	<dl>
		<dt><b>source</b></dt>
		<dd>
		The name of the file (program reads and processes this file) in one of the supported <a href="#formats">formats</a>. The <i>source</i> must end with a valid format extension or the optional <i>--source_format</i> argument must be used. If the <i>source</i> is omitted or if it equals to "-", the program reads the input from the <i>stdin</i>.
		</dd>
	</dl>
	<h3 id="opt_args">Optional arguments</h3>
	<dl>
		<dt><b>-h, --help</b></dt>
		<dd>Print the help message to the <i>stdout</i> and exit.</dd>

		<dt><b>-t</b> target, <b>--target</b> target</dt>
		<dd>
		The name of the file (program writes to this file) in one of the supported <a href="#formats">format</a>. The <i>--target</i> must end with a valid format extension or the optional <i>--target_format</i> argument must be used. If the <i>--target</i> is omitted or if it equals to "-", the program writes the input to the <i>stdout</i>.
		</dd>

		<dt><b>-ta </b>target_attributes, <b>--target_attributes</b> target_attributes</dt>
		<dd>
		The list of formulas separated by ";",
		<pre><code>formulas ::= formula | (formula ";" formulas)</code></pre>
		where formula is a definition of attribute in the target file. The formula is of the form:
		<pre><code>formula ::= (new-names "=")? old-names ((":" type ("[" scale "]")?) | "[]")?</code></pre>
		<u>The first part</u> of the formula:
		<pre><code>(new-names "=")? old-names</code></pre>
		where new-names and old-names are the lists of names separated by ",":
		<pre><code>names ::= name | (name "," names)</code></pre>
		where name is a word or an interval:
		<pre><code>name ::= \w+ | ((\d+)? "-" (\d+)?) | "*"</code></pre>
		has the following meaning: old-names refer to attributes in the source file by using their names (if are available) or indexes. New-names define new names of attributes used in the target file. If new-names are omitted, attributes in the target file have same names as in the source file. New-names and old-names must have the same length, otherwise error is produced.
		<p>
		The interval determines a range of indexes. If the lower bound is omitted, indexes range is from zero to upper bound. If the upper bound is omitted, indexes range is from lower bound to the maximum index of attribute in the source file. If both upper and lower bounds are omitted, indexes range is from zero to the maximum index of the attribute in the source file (for this case has been added alias "*", which has the same meaning as "-").
		</p>
		Examples (seven attributes in source file):
		<table>
			<tr><td>
			<code>4-6 produces: 4, 5, 6</code>
			</td></tr>

			<tr><td>
			<code>-5 produces: 0, 1, 2, 3, 4, 5</code>
			</td></tr>

			<tr><td>
			<code>4- produces: 4, 5, 6, 7</code>
			</td></tr>

			<tr><td>
			<code>- produces: 0, 1, 2, 3, 4, 5, 6, 7</code>
			</td></tr>

			<tr><td>
			<code>* produces: 0, 1, 2, 3, 4, 5, 6, 7</code>
			</td></tr>
		</table>
		<p><u>The second optional part</u> of the formula</p>
		<pre><code>((":" type ("[" scale "]")?) | "[]")?</code></pre>
		is composed of the attribute type,
		<pre><code>type ::= "n" | "e" | "s" | ("d" ("/" date_format)?)
date_format ::= "F="? "'" .+ "'"</code></pre>
		where characters are aliases of data types:
		<ul>
			<li>n = numeric - all real numbers</li>
			<li>e = enumeration (nominal) - finite set of named values</li>
			<li>s = string - word</li>
			<li>d = date - the default date format is ISO-8601 which combines date and time: YYYY-MM-DDThh:mm:ss. For using different date formats must be used <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">python format codes</a>,</li>
		</ul>
		<p>optional definition of the scale and the <a href="#unpack">binary unpacking</a>.</p>
		<pre><code>scale ::= num_scale | enum_scale | str_scale | date_scale | bin_vals</code></pre>
		The scale is an expression which is evaluated with a value of the attribute. Result of evaluation is True or False represented as 0 and 1.
		<p>In the <i>numeric scale</i>,</p>
		<pre><code>num_scale ::= (var op num_val) | (num_val op var) | (num_val op var op num_val)</code></pre>
		the numeric value is of the form:
		<pre><code>num_val ::= int ("." int?)? ("e" int)?
int ::= ("+" | "-")? \d+</code></pre>
		Examples of numeric value: <code>5, -10, +47, 2.46, -2.31, +98.31, -78.4e-48, 3e8</code>
		<pre><code>var ::= [a-z_]+</code></pre>
		Variable (the form above) represents a value of the scale evaluation. Operations have the same meaning as in many programming languages such as C or Python.
		<pre><code>op ::= "<" | ">" | "<=" | ">=" | "==" | "!="</code></pre>
		Examples of numeric scales (variable is x): <code>x!=10.3, -5<=x<=10, 50==x </code>
		<p>The <i>enumeration scale</i></p>
		<pre><code>enum_scale ::= "'" \w+ "'"</code></pre>
		is a one of enumeration values, which must be quoted. If the value of the attribute is exactly the same as the scale, the result of the scaling is True, otherwise False.
		<p>The <i>string scale</i></p>
		<pre><code>str_scale ::= "'" .+ "'"</code></pre>
		is a quoted <a href="https://docs.python.org/2/library/re.html"> python regular expression</a>. If the regular expression matches any substring of the scaled value, result of scaling is True, otherwise False.
		<p>Example of the string scale: <code>"foo[+-*]*bar"</code>, which matches "hellfoobar", "foo--barxyz" ... but doesn't match "foo/bar" ...</p>
		<p>The <i>date scale</i></p>
		<pre><code>date_scale ::= ((var op date_val) | (date_val op var) | (date_val op var op date_val))</code></pre>
		is exactly the same expression as numeric scale, but values must be dates in valid date format.
		<p><i>Binary values</i></p>
		<pre><code>bin_vals ::= ("0="? "'" .* "'" ",")? "1="? "'" .+ "'"</code></pre>
		allow to define new <i>binary values</i> for some bivalent attribute. The default values are 1 (True) and 0 (False). This can be useful for the conversion from multivalent format (which contains bivalent attribute, but values are different from 0 and 1) to bivalent format, without useless scaling (because values are bivalent already). Note that, this way is semantically the same as using enumeration for bivalent attribute, but use of <i>binary values</i> is prefered because is more time-efficient.
		<p id="unpack">
		The alternative to the scale is a <i>binary unpacking</i> (total binarization) of an attribute, which can be used by "[]", written just behind the names. This creates new attribute for every single value of the old attribute. Every new attribute is of a type enumeration with the scale: value. The order of new attributes is the same as the order of values in template attribute. If <i>binary unpacking</i> is used for more attributes, for example for two attributes, then every new attribute of the first old attribute has lower index then any of new attribute of the second old attribute.
		</p>
		<p>Example - <i>binary unpacking</i> of two attributes:</p>
		<table>
			<tr>
				<td>in
<pre>
a x
b y
b z
a x
c y
</pre>
				</td>
				<td>out
<pre>
1 0 0  1 0 0
0 1 0  0 1 0
0 1 0  0 0 1
1 0 0  1 0 0
0 0 1  0 1 0
</pre>
				</td>
			</tr>
		</table>
		<p>Complete grammar of the <i>--target_attributes</i> argument:</p>
		<pre><code>formulas ::= formula | (formula ";" formulas)
formula ::= (names "=")? names ((":" type ("[" scale "]")?) | "[]")?
names ::= name | (name "," names)
type ::= "n" | "e" | "s" | ("d" ("/" date_format)?)
scale ::= num_scale | enum_scale | str_scale | date_scale | bin_vals
name ::= \w+ | ((\d+)? "-" (\d+)?) | "*"
date_format ::= "F="? "'" .+ "'"
num_scale ::= (var op num_val) | (num_val op var) |
              (num_val op var op num_val)
enum_scale ::= "'" \w+ "'"
str_scale ::= "'" .+ "'"
date_scale ::= ((var op date_val) | (date_val op var) |
                (date_val op var op date_val))
bin_vals ::= ("0="? "'" .* "'" ",")? "1="? "'" .+ "'"
var ::= [a-zA-Z_]+
op ::= "<" | ">" | "<=" | ">=" | "==" | "!="
date_val ::= "'" .+ "'"
num_val ::= int ("." int?)? ("e" int)?
int ::= ("+" | "-")? \d+</code></pre>
		<i>Notes: </i>
		<p>If the <i>--target_attributes</i> argument is omitted, all attributes   from the <i>source</i> are processed.</p>
		<p>If the <i>--target_attributes</i> argument beginning with "-" (e.g <code>'-4,8,9'</code>), the <i>--target_attributes</i> must be specified as: <code>-ta='-4,8,9'</code>. </p>
		</dd>

		<dt><b>-c</b> [rows_count], <b>--convert</b> [rows_count]</dt>
		<dd>
			Converts the <i>source</i> to the <i>--target</i>. The optional argument rows_count defines how many rows of data should be processed.
		</dd>

		<dt><b>-p</b> [rows_count], <b>--preview</b> [rows_count]</dt>
		<dd>Prints desired count of rows from the <i>source</i> table data in to the <i>stdout</i>. The default amount of printed rows is 20, but this value can be changed by using the optional argument rows_count.
		</dd>

		<dt><b>-i, --info</b></dt>
		<dd>
		Prints a statistics of the <i>source</i> and for its each processed attribute. Statistics is of the form:
<pre>Relation name:
Objects count:
Attributes count:
====================

name:
index:
type: string/enumeration
values appearance:
    value: occurrences-count/total-count = %
	.
	.
	.

name:
index:
type: numeric/date
max: , min:
values appearance:
    value: occurrences-count/total-count = %
	.
	.
	.

.
.
.</pre>
		The <i>--info</i> may be used as single action (the statistics is printed to the <i>stdout</i>) or in parallel with a conversion (if <i>--target</i> is <i>stdout</i>, the new file, named same as the <i>source</i>, but with extension .info is produced). The usage <i>--info</i> in parallel with conversion is useful for the saving time if both actions are required.
		</dd>

		<dt><b>-sf</b> {csv,arff,dat,data,cxt,dtl},
			<b>--source_format</b> {csv,arff,dat,data,cxt,dtl}</dt>
		<dd>
		Specifies the <i>source</i> format using the extension. If the <i>source</i> doesn't have the extension, the <i>--source_format</i> is required. If the <i>source</i> has the extension and <i>--source_format</i> is also used, the <i>--source_format</i> overwrites the <i>source</i> extension.
		</dd>

		<dt><b>-tf</b> {csv,arff,dat,data,cxt,dtl},
			<b>--target_format</b> {csv,arff,dat,data,cxt,dtl}</dt>
		<dd>
		Specifies the <i>--target</i> format using the extension. If the <i>--target</i> doesn't have the extension, the <i>--target_format</i> is required. If the <i>--target</i> has the extension and <i>--target_format</i> is also used, the <i>--target_format</i> overwrites the <i>--target</i> extension.
		</dd>

		<dt><b>-cls</b> classes,
			<b>--classes</b> classes
		</dt>
		<dd>
		Selects attributes from the <i>source</i>, to be used as classes in the <i>--target</i>. It can be specified using the interval of attribute indexes, or using names of attributes, or both in combination. <i>--classes</i> is of the form:
		<pre><code>classes ::= element | (element "," classes)
element = interval | key
interval ::= ((\d+)? "-" (\d+)?)
key = \w+</code></pre>

		This argument is relevant only in the case, when the <i>--target</i> format is <a href="#data">C4.5</a> or <a href="#dtl">DTL</a>.
		</dd>

		<dt><b>-ss</b> source_separator,
			<b>--source_separator</b> source_separator
		</dt>
		<dd>
		Specifies the separator of attributes in the <i>source</i> (it affects only the current action). <i>--source_separator</i> must be specified, when the separator used in the <i>source</i> is a different from a default file format separator.
		</dd>

		<dt><b>-ts</b> target_separator,
			<b>--target_separator</b> target_separator
		</dt>
		<dd>
		Specifies the separator of attributes in the <i>--target</i> (it affects only the current action). Attributes in the <i>--target</i> will be separated with this new value.
		</dd>

		<dt><b>-scs</b> source_classes_separator,
			<b>--source_cls_separator</b> source_classes_separator
		</dt>
		<dd>
		Specifies the separator of attributes and classes in the <i>source</i> (it affects only the current action). <i>--source_cls_separator</i> must be specified, when the classes/attributes separator used in the <i>source</i> is a different from a default file format classes/attributes separator. This argument is relevant only in the case, when the <i>source</i> format is <a href="#dtl">DTL</a>.
		</dd>

		<dt><b>-tcs</b> target_classes_separator,
			<b>--target_cls_separator</b> target_classes_separator
		</dt>
		<dd>
		Specifies the  separator of attributes and classes in the <i>--target</i> (it affects only the current action). Attributes and classes in the <i>--target</i> will be separated with this new value. This argument is relevant only in the case, when the <i>--target</i> format is <a href="#dtl">DTL</a>.
		</dd>

		<dt><b>-sl</b> skip_lines,
			<b>--skip_lines</b> skip_lines
		</dt>
		<dd>
		The interval of the form
		<pre><code>interval ::= (\d+)? "-" (\d+)?</code></pre>
		specifies <i>source</i> indexes of lines, which will be skipped in any action.
		</dd>

		<dt><b>-se</b>,
			<b>--skip_errors</b>
		</dt>
		<dd>
		Errors produced by invalid lines in the <i>source</i> are skipped. Program continues and skipped errors are printed to the <i>stderr</i>.
		</dd>

		<dt><b>-n</b> name,
			<b>--name</b> name
		</dt>
		<dd>
		Specifies a new name of relation (data).
		</dd>

		<dt><b>-mv</b> missing_value,
			<b>--missing_value</b> missing_value
		</dt>
		<dd>
		Specifies the value, which will be interpreted as an undefined value (None/NULL). The result of scaling the <i>--missing_value</i> is always False (0).
		</dd>

		<dt><b>-o</b> objects,
			<b>--objects</b> objects
		</dt>
		<dd>
		The list of object names separated by comma:
		<pre><code>objects ::= name | (name "," objects)</code></pre>
		This argument is relevant only in the case, when <i>--target</i> format is <a href="#cxt">Burmeister</a>. If <i>--objects</i> is omitted, indexes of objects are used.
		</dd>

		<dt><b>-snh</b> source_no_header,
			<b>--source_no_header</b> source_no_header
		</dt>
		<dd>
		The first row in the <a href="#csv">CSV</a>  <i>source</i> is interpreted as an object (not header).
		</dd>

		<dt><b>-tnh</b> target_no_header,
			<b>--target_no_header</b> target_no_header
		</dt>
		<dd>
		The <a href="#csv">CSV</a> <i>--target</i> will have an object on the first line (not header).
		</dd>

	</dl>


	<h3 id="errors">Errors</h3>
	The errors below are produced by the program. Each error specification is of the form:
<pre><code>error_code: error_name
	error_description
</code></pre>
	When an error is raised, program ends and returns an error code.
	<dl>
		<dt><b>1</b>: Swift Unknown Error</dt>
		<dd>If you get this error, please <a href="#bugs">report</a> a bug with an error message printed below. Thank you.</dd>

		<dt><b>2</b>: Argument Error</dt>
		<dd>Some of required arguments are missing or aren't specified correctly.</dd>

		<dt><b>3</b>: ARFF Header Error</dt>
		<dd>The syntax error in the header of the ARFF <i>source</i> file.</dd>

		<dt><b>4</b>: DATA Header Error</dt>
		<dd>The syntax error in the header of the DATA <i>source</i> file.</dd>

		<dt><b>5</b>: CSV Header Error</dt>
		<dd>The syntax error in the header of the CSV <i>source</i> file.</dd>

		<dt><b>6</b>: DAT header Error</dt>
		<dd>The syntax error in the header of the DAT <i>source</i> file.</dd>

		<dt><b>7</b>: CXT Header Error</dt>
		<dd>The syntax error in the header of the CXT <i>source</i> file.</dd>

		<dt><b>8</b>: ARFF Line Error</dt>
		<dd>The syntax error in the line of the ARFF <i>source</i> file.</dd>

		<dt><b>9</b>: DATA Line Error</dt>
		<dd>The syntax error in the line of the DATA <i>source</i> file.</dd>

		<dt><b>10</b>: CSV Line Error</dt>
		<dd>The syntax error in the line of the CSV <i>source</i> file.</dd>

		<dt><b>11</b>: DAT Line Error</dt>
		<dd>The syntax error in the line of the DAT <i>source</i> file.</dd>

		<dt><b>12</b>: CXT Line Error</dt>
		<dd>The syntax error in the line of the CXT <i>source</i> file.</dd>

		<dt><b>13</b>: DTL Line Error</dt>
		<dd>The syntax error in the line of the DTL <i>source</i> file.</dd>

		<dt><b>14</b>: Formula Error</dt>
		<dd>The syntax error in some formula of the <i>--target_attributes</i> argument.</dd>

		<dt><b>15</b>: Formula Names Error</dt>
		<dd>The count of new names and the count of old names aren't equal.</dd>

		<dt><b>16</b>: Sequence Error</dt>
		<dd>The syntax error in a sequence (interval).</dd>

		<dt><b>17</b>: DATE Value Error</dt>
		<dd>The invalid value of a date attribute.</dd>

		<dt><b>18</b>: NUMERIC Value Error</dt>
		<dd>The invalid value of a numeric attribute.</dd>

		<dt><b>19</b>: STRING Value Error</dt>
		<dd>The invalid value of a string attribute.</dd>

		<dt><b>20</b>: NOMINAL Value Error</dt>
		<dd>The invalid value of a nominal (enumeration) attribute.</dd>

		<dt><b>21</b>: DATE Error</dt>
		<dd>The invalid syntax of a date.</dd>

		<dt><b>22</b>: Formula Date Value/Format Error</dt>
		<dd>The value and the format of the date doesn't match.</dd>

		<dt><b>23</b>: Formula Regular Expression Error</dt>
		<dd>The invalid regular expression in the formula.</dd>

		<dt><b>24</b>: Formula Attribute Key Error</dt>
		<dd>The given key of the attribute doesn't exists.</dd>

		<dt><b>25</b>: Keyboard Interrupt Error</dt>
		<dd></dd>

		<dt><b>26</b>: Bivalent Error</dt>
		<dd>The invalid bivalent value in data.</dd>

		<dt><b>27</b>: Broken Pipe Error</dt>
		<dd></dd>

		<dt><b>28</b>: Names File Error</dt>
		<dd>Files: .names and .data (C4.5 format) aren't in the same directory.</dd>

		<dt><b>29</b>: DTL Header Error</dt>
		<dd>The syntax error in the header of the DTL <i>source</i> file.</dd>

	</dl>


	<h2 id="formats">SUPPORTED FORMATS</h2>
	Swift supports following six formats: <a href="#csv">CSV</a>, <a href="#arff">ARFF</a>, <a href="#data">DATA</a>, <a href="#cxt">CXT</a>, <a href="#dat">DAT</a> and <a href="#dtl">DTL</a>.
		<h3 id="csv">Comma-separated values (.csv)</h3>
			The description of the format with examples can be found <a href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.
			<p><i>Notes: </i>The attribute separator inside the value must be always escaped by the backslash.</p>

		<h3 id="arff">Attribute-Relation File Format (.arff)</h3>
			The description of the format with examples can be found <a href="http://weka.wikispaces.com/ARFF+%28stable+version%29">here</a>.
			<p><i>Notes:</i> The optional date format for the date attribute in the header, must be specified with python <a href="https://docs.python.org/3.5/library/datetime.html#strftime-and-strptime-behavior">format codes</a> (not in the Java SimpleDateFormat as specified in the official documentation).</p>
			Example:
<pre><code>@relation birthdays
@attribute birthday date %Y-%m-%d
@data
1990-04-23
1993-12-03
1989-03-31</code></pre>

<p>When converting from an arff file with some relational attributes to some other format, relational attributes are linearized (using dot notation, see example).</p>
Example:
<pre><code>@attribute humidity relational
    @attribute absolute relational
        @attribute day numeric
        @attribute night numeric
    @end absolute
@end humidity</code></pre>

The relational attribute humidity (above) will be converted to attributes (e.g for csv target):
<pre><code>humidity.absolute.day, humidity.absolute.night</code></pre>

		<h3 id="data">C4.5 File Format (.data .names)</h3>
		The description of the format with examples can be found <a href="http://www.cs.washington.edu/dm/vfml/appendixes/c45.htm">here</a>.
		<p><i>Notes: </i>With a class, must be worked exactly the same as with an attribute at any conversion (class can be scaled, total binarized, ...). The key used in the <i>--target_attributes</i> is the class index or the name: "class".</p>

		<h3 id="cxt">Burmeister (.cxt)</h3>
		The description of the format with examples can be found <a href="http://www.upriss.org.uk/fca/fcafileformats.html#Burmeister">here</a>.

		<h3 id="dat">FIMI File Format (.dat)</h3>
		The description of the format with examples can be found <a href="http://fcalgs.sourceforge.net/format.html">here</a>.
		<p><i>Notes: </i>The blank lines are interpreted (from FIMI source) as objects, with all attributes of the value 0 (False). And conversely objects with all attributes of the value 0 (False), are written (to FIMI target) as blank lines. It differs from the official format documentation, which ignore blank lines and objects with all attributes of value 0.</p>

		<h3 id="dtl">DTL File Format (.dtl)</h3>
		<p>This format is very similar to FIMI, but it supports specification of classes for each object. The file consists of rows, which are of the form:
		<pre><code>attributes "|" classes</code></pre>
		where attributes part is exactly the same as attributes in the FIMI format (values are indexes of attributes with value 1) and "|" separates attributes and classes. The classes part consists of various values, separated with the same separator as attributes are.</p>
		Example (<code>class1={a,b}, class2={aa,bb}</code>):
<pre><code>0 1 2 3 4|a bb
1 2 3 4|a aa
2 3 4|b bb
3 4|a bb
4|b bb</code></pre>

		<p>With classes must be worked exactly the same as with the attributes at any conversion (class can be scaled, total binarized, ...). The key used in the <i>--target_attributes</i> is the class index or the name: "class1", "class2"... .</p>

	<h2 id="examples">EXAMPLES</h2>
	All examples is this section use following sample data.
	<h3 id="sample_data">Sample data</h3>
	<dl>
		<dt id="ex_csv">CSV - example.csv</dt>
		<dd>
<pre><code>name,   birth_date, credits, study, sex
George, 1991-06-13, 54,      true,  man
Monica, 1990-04-23, 98,      false, woman
Mia,    ?,          87,      true,  woman
John,   1989-11-11, 91,      true,  man</code></pre>
		</dd>

		<dt id="ex_dtl">DTL - example.dtl</dt>
		<dd>
<pre><code>0 1 2 3 4|a bb
1 2 3 4|a aa
2 3 4|b bb
3 4|a bb
4|b bb</code></pre>
		</dd>

		<dt id="ex_dat">DAT - example.dat</dt>
		<dd>
<pre><code>0
1
2
3
4</code></pre>
		</dd>

		<dt id="ex_data">DATA</dt>
		<dd>
		example.names
<pre><code>foo, bar.
age: continuous.
job: teacher, pilot, doctor.
work: discrete 2.
sport: ignore.</code></pre>
example.data
<pre><code>44, doctor,  1, foo
30, teacher, 0, bar
35, ?,       1, foo
31, pilot,   0, foo
</code></pre>
		</dd>

	</dl>
	<h3 id="convert">Convert</h3>
	This section is divided into nine subsections according arguments, which are required in the particular conversion. Each of the subsections contains the list of the required arguments, one illustrative example and the list of next conversions, which can be used similarly.
	<p>For the quick navigation, you can use the following table of all possible conversions.</p>
	<dl>
		<table>
		<tr>
		<td>
		<ul>
			<li><a href="#simple">CSV to CSV</a></li>
			<li><a href="#type_spec">CSV to ARFF</a></li>
			<li><a href="#types_cls_spec">CSV to DATA</a></li>
			<li><a href="#scale_obj_spec">CSV to CXT</a></li>
			<li><a href="#scale">CSV to DAT</a></li>
			<li><a href="#scale_cls_spec">CSV to DTL</a></li>
		</ul>
		</td>
		<td>
		<ul>
			<li><a href="#simple">ARFF to ARFF</a></li>
			<li><a href="#simple">ARFF to CSV</a></li>
			<li><a href="#cls_spec">ARFF to DATA</a></li>
			<li><a href="#scale_obj_spec">ARFF to CXT</a></li>
			<li><a href="#scale">ARFF to DAT</a></li>
			<li><a href="#scale_cls_spec">ARFF to DTL</a></li>
		</ul>
		</td>
		<td>
		<ul>
			<li><a href="#cls_spec">DATA to DATA</a></li>
			<li><a href="#simple">DATA to ARFF</a></li>
			<li><a href="#simple">DATA to CSV</a></li>
			<li><a href="#scale_obj_spec">DATA to CXT</a></li>
			<li><a href="#scale">DATA to DAT</a></li>
			<li><a href="#scale_cls_spec">DATA to DTL</a></li>
		</ul>
		</td>
		</tr>
		<tr>
		<td>
		<ul>
			<li><a href="#simple">CXT to CXT</a></li>
			<li><a href="#cls_spec">CXT to DATA</a></li>
			<li><a href="#simple">CXT to ARFF</a></li>
			<li><a href="#simple">CXT to CSV</a></li>
			<li><a href="#simple">CXT to DAT</a></li>
			<li><a href="#cls_spec">CXT to DTL</a></li>
		</ul>
		</td>
		<td>
		<ul>
			<li><a href="#simple">DAT to DAT</a></li>
			<li><a href="#obj_atrr_spec">DAT to CXT</a></li>
			<li><a href="#cls_spec">DAT to DATA</a></li>
			<li><a href="#simple">DAT to ARFF</a></li>
			<li><a href="#simple">DAT to CSV</a></li>
			<li><a href="#cls_spec">DAT to DTL</a></li>
		</ul>
		</td>
		<td>
		<ul>
			<li><a href="#scale_cls_spec">DTL to DTL</a></li>
			<li><a href="#scale">DTL to DAT</a></li>
			<li><a href="#scale_obj_attr_spec">DTL to CXT</a></li>
			<li><a href="#cls_spec">DTL to DATA</a></li>
			<li><a href="#simple">DTL to ARFF</a></li>
			<li><a href="#simple">DTL to CSV</a></li>
		</ul>
		</td>
		</tr>
		</table>

		<h4 id="simple">Simple Conversion</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
		</ul>

		<dt>DTL (<a href="#ex_dtl">example.dtl</a>) to CSV</dt>
	<dd>
		<pre><code>swift-cli.py example.dtl -t result.csv</code></pre>
		result.csv
<pre><code>
0,1,2,3,4,class1,class2
1,1,1,1,1,a,bb
0,1,1,1,1,a,aa
0,0,1,1,1,b,bb
0,0,0,1,1,a,bb
0,0,0,0,1,b,bb
</code></pre>
	<i>Next possible conversions:</i>
	<ul>
		<li>CSV to CSV</li>
		<li>ARFF to ARFF</li>
		<li>ARFF to CSV</li>
		<li>DATA to CSV</li>
		<li>DATA to ARFF</li>
		<li>DAT to DAT</li>
		<li>DAT to CSV</li>
		<li>DAT to ARFF</li>
		<li>CXT to CXT</li>
		<li>CXT to CSV</li>
		<li>CXT to DAT</li>
		<li>CXT to ARFF</li>
		<li>DTL to ARFF</li>
	</ul>

	</dd>

		<h4 id="type_spec">Types specification</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--target_attributes</i> (with types specification)</li>
		</ul>

		<dt>CSV (<a href="#ex_csv">example.csv</a>) to ARFF</dt>
		<dd>
		<pre><code>swift-cli.py example.csv -t result.arff -mv '?' -ta "name:s; 1:d/'%Y-%m-%d'; credits:n; work,gender=3,4:e" -n people</code></pre>
		result.arff
<pre><code>@relation people

@attribute name string
@attribute birth_date date %Y-%m-%d
@attribute credits numeric
@attribute work { true,false }
@attribute gender { man,woman }

@data
George,1991-06-13,54,true,man
Monica,1990-04-23,98,false,woman
Mia,?,87,true,woman
John,1989-11-11,91,true,man</pre></code>
		</dd>

		<h4 id="cls_spec">Classes specification</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--classes</i></li>
		</ul>

		<dt>DATA (<a href="#ex_data">example.data</a>) to DATA</dt>
		<dd>
		<pre><code>swift-cli.py example.data -t result.data -cls class </code></pre>
		result.names
<pre><code>foo,bar.
age: continuous.
job: teacher,pilot,doctor.
work: 1,0.
class_prev: foo,bar.</code></pre>
		result.data
<pre><code>44,doctor,1,foo,foo
30,teacher,0,bar,bar
35,?,1,foo,foo
31,pilot,0,foo,foo</code></pre>
	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to DATA</li>
		<li>DATA to DATA</li>
		<li>DAT to DTL</li>
		<li>DAT to DATA</li>
		<li>CXT to DATA</li>
		<li>CXT to DTL</li>
		<li>DTL to DATA</li>
	</ul>

		</dd>

	<h4 id="types_cls_spec">Types, classes specification</h4>
		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--target_attributes</i> (with types specification)</li>
			<li><i>--classes</i></li>
		</ul>
		<dt>CSV (<a href="#ex_csv">example.csv</a>) to DATA</dt>
		<dd>
		<pre><code>swift-cli.py example.csv -t result.data -mv '?' -ta "name:s; 1:d/'%Y-%m-%d'; credits:n; 3,4:e" -cls sex</code></pre>
		result.names
<pre><code>man,woman.
name: discrete n.
birth_date: discrete n.
credits: continuous.
study: true,false.
sex: man,woman.</code></pre>
		result.data
<pre><code>George,1991-06-13,54,true,man,man
Monica,1990-04-23,98,false,woman,woman
Mia,?,87,true,woman,woman
John,1989-11-11,91,true,man,man</code></pre>
		</dd>

		<h4 id="obj_atrr_spec">Object names and attribute names specification</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--objects</i></li>
			<li><i>--target_attributes</i> (with new names, if omitted, indexes of objects are used instead)</li>
		</ul>

	<dt>DAT (<a href="#ex_dat">example.dat</a>) to CXT</dt>
	<dd>

	<pre><code>swift-cli.py example.dat -t result.cxt -o foo,bar,foobar,barfoo -ta 'a=0;b=1;c=2;d=3'</code></pre>
	result.cxt
<pre><code>B

4
4
foo
bar
foobar
barfoo
a
b
c
d
X...
.X..
..X.
...X</code></pre>
	</dd>

	<h4 id="scale">Scale</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--target_attributes</i> (with scaling formulas)</li>
		</ul>

	<dt>CSV (<a href="#ex_csv">example.csv</a>) to DAT</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -mv '?' -t result.dat -ta "name:s['M.+a']; birth_date:d/'%Y-%m-%d'[x&gt='1991-01-01'];
             credits:n[50&lt=x&lt=90]; study:e['true']; sex:e['man']"</code></pre>
result.dat
<pre><code>1 2 3 4
0
0 2 3
3 4</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to DAT</li>
		<li>DATA to DAT</li>
		<li>DTL to DAT</li>
	</ul>
	</dd>

	<h4 id="scale_obj_spec">Scale and object names specification</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--objects</i></li>
			<li><i>--target_attributes</i> (with scaling formulas)</li>
		</ul>

	<dt>CSV (<a href="#ex_csv">example.csv</a>) to CXT</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -mv '?' -t result.cxt -o a,b,c,d -ta "name:s['M.+a'];
	     birth_date:d/'%Y-%m-%d'[x&gt='1991-01-01']; credits:n[50&lt=x&lt=90]; study:e['true']; sex:e['man']"</code></pre>
	result.cxt

<pre id="res_cxt"><code>B

4
5
a
b
c
d
name
birth_date
credits
study
sex
.XXXX
X....
X.XX.
...XX</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to CXT</li>
		<li>DATA to CXT</li>
	</ul>
	</dd>

	<h4 id="scale_cls_spec">Scale and classes specification</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--target_attributes</i> (with scaling formulas)</li>
			<li><i>--classes</i></li>
		</ul>

	<dt>CSV (<a href="#ex_csv">example.csv</a>) to DTL</dt>

	<dd>
	<pre><code>swift-cli.py example.csv -mv '?' -t result.dtl -cls 3,4 -ta "name:s['M.+a'];
	     birth_date:d/'%Y-%m-%d'[x&gt='1991-01-01']; credits:n[50&lt=x&lt=90]; study:e['true']; sex:e['man']"</code></pre>
	result.dtl
<pre><code>1 2 3 4|true man
0|false woman
0 2 3|true woman
3 4|true man</code></pre>

	<i>Next possible conversions:</i>
	<ul>
		<li>ARFF to DTL</li>
		<li>DATA to DTL</li>
		<li>DTL to DTL</li>
	</ul>

	</dd>

	<h4 id="scale_obj_attr_spec">Scale, object names and attribute names specification</h4>

		<i>Required arguments:</i>
		<ul>
			<li><i>source</i></li>
			<li><i>--target / --target_format</i></li>
			<li><i>--target_attributes</i> (with scaling formulas and new attribute names, if names are omitted, indexes of objects are used instead).</li>
			<li><i>--objects</i></li>
		</ul>
	<dt>DTL (<a href="#ex_dtl">example.dtl</a>) to CXT</dt>
	<dd>
	<pre><code>swift-cli.py example.dtl -t result.cxt -ta "b1,b2,b3,b4,b5=0-4;class1:e['b'];class2:e['bb']" -o a,b,c,d,e</code></pre>
	<pre><code>B

5
7
a
b
c
d
e
b1
b2
b3
b4
b5
class1
class2
XXXXX.X
.XXXX..
..XXXXX
...XX.X
....XXX</code></pre>
	</dd>
	</dl>
	<h3 id="bin_unpack">Binary Unpacking</h3>
	<dl>
	<dt>CSV (<a href="#ex_csv">example.csv</a>) to CSV</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -t result.csv csv -ta "*[]" -tnh</code></pre>
	result.csv
	<pre><code>1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0
0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1
0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1
0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0</code></pre>
	</dd>
	</dl>

	<h3 id="filter">Filter</h3>

	<dl>
	<dt>CSV (<a href="#ex_csv">example.csv</a>) to CSV</dt>
	<dd>
	<pre><code>swift-cli.py example.csv -t result.csv -ta "study;name" -sl "2-"</code></pre>
	<pre><code>study,name
true,George
false,Monica</code></pre>
	</dd>
	</dl>

	<h3 id="info">Info</h3>

	<dl>
	<dt>DATA (<a href="#ex_data">example.data</a>)</dt>
	<dd>
	<pre><code>swift-cli.py example.data -i</code></pre>
	<pre><code>Relation name:
Objects count: 4
Attributes count: 4
====================

name: age
index: 0
type: numeric
max: 44.0, min: 30.0
values appearance:
    44.0: 1/4 = 25.00%
    30.0: 1/4 = 25.00%
    35.0: 1/4 = 25.00%
    31.0: 1/4 = 25.00%

name: job
index: 1
type: nominal
values appearance:
    ?: 1/4 = 25.00% (none value)
    doctor: 1/4 = 25.00%
    teacher: 1/4 = 25.00%
    pilot: 1/4 = 25.00%

name: work
index: 2
type: nominal
values appearance:
    1: 2/4 = 50.00%
    0: 2/4 = 50.00%

name: class
index: 3
type: nominal
values appearance:
    bar: 1/4 = 25.00%
    foo: 3/4 = 75.00%</code></pre>
	</dd>
	</dl>

	<h3 id="preview">Preview</h3>

	<dl>
	<dt>DAT (<a href="#ex_dat">example.dat</a>)</dt>
	<dd>
	<pre><code>swift-cli.py example.dat -p</code></pre>
	<pre><code>0 1 2 3
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1</code></pre>
	</dd>
	</dl>

	<h2 id="installation">INSTALLATION</h2>

	<h3 id="requirements">Requirements</h3>
	Make sure that following dependencies are installed in your computer:
	<ul>
	<li>
	<a href="https://www.python.org/">Python3</a>
	</li>
	<li>
	<a href="http://www.riverbankcomputing.co.uk/software/pyqt/intro">PyQt4</a>
	</li>
	<li>
	<a href="https://pyparsing.wikispaces.com/">Pyparsing</a>
	</li>
	</ul>
	<h3 id="download">Download</h3>

	This program can be obtained from the <a href="https://github.com/gnovis/swift">repository</a> using git:
	<pre><code>git clone git@github.com:gnovis/swift.git</code></pre>
	or by the direct <a href="https://github.com/gnovis/swift/zipball/master/">link</a>.

	<h3 id="unpackzip">Unpack</h3>
	If you download the source through the direct link, you need to unpack the ZIP archive. For example by using the <a href="http://www.info-zip.org/mans/unzip.html">unzip</a> program (on Linux):
<pre><code>cd ~/Downloads
unzip swift-master
mv swift-master swift</code></pre>

	<h3 id="finish">Finish</h3>
	Go to the swift directory <code>cd path/to/swift/</code> and start using swift with <code>swift-cli.py</code> or <code>swift.py</code> scripts.

	<h2 id="bugs">REPORTING BUGS</h2>
	If you find a bug, please create an issue with a description via the <a href="https://github.com/gnovis/swift/issues">issue tracker</a>.
	<h2 id="contribute">CONTRIBUTING</h2>
	You are welcome to participate in development of this project. Join us on <a href="https://github.com/gnovis/swift">github</a>.
	<h2 id="authors">AUTHORS</h2>
	Created by Jan Novacek &lt;novacekj5@gmail.com&gt; and Jan Outrata &lt;jan.outrata@upol.cz&gt;.
	<h3 id="proofreaders">Proofreaders</h3>
	Veronika Novackova &lt;veronika.novackovaa@gmail.com&gt;
	<h2 id="website">WEBSITE</h2>
	The project website: <a href="http://gnovis.github.io/swift/">http://gnovis.github.io/swift/</a>.
	<h2 id="licence">LICENSE</h2>
	Swift  is  distributed  under the <a href="http://www.gnu.org/licenses/gpl-3.0.html">GNU GPL v3</a>.

</div>

<div id="footer">
	<img id="footer_icon" src="./img/swift_icon.svg">
	<span id="copy">Swift - Relational Data Converter &copy; 2016</span>
</div>

</body>
</html>
