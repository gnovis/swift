 <!DOCTYPE html>
<html>
	<head>
		<title>Swift</title>
	</head>
<body>
	<h1>Swift</h1>

	<h2>NAME</h2>
	<p>Swift - Relational Data Converter</p>

	<h2>SYNOPSIS</h2>
	<table>
		<tr>
			<td><b>swift-cli.py</b></td>
			<td>
				[<b>-h</b>] [<b>-ss</b> source_separator] [<b>-ta</b> target_attributes] [<b>-i</b>]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-mv</b> missing_value] [<b>-snh</b>] [<b>-tnh</b>] [<b>-t</b> [target]]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-ts</b> target_separator] [<b>-to</b> target_objects] [<b>-n</b> name]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-cls</b> classes] [<b>-sf</b> {csv,arff,dat,data,cxt,dtl}]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-tf</b> {csv,arff,dat,data,cxt,dtl}] [<b>-c</b> [rows_count]] [<b>-p</b> [rows_count]]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-sl</b> skipped_lines] [<b>-se</b>] [<b>-scs</b> source_cls_separator]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [<b>-tcs</b> target_cls_separator]
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
	             [source]
			</td>
		</tr>
		<tr>
			<td><b>swift.py</b></td>
			<td></td>
		</tr>
	</table>

	<h2>DESCRIPTION</h2>
	Swift - Relational Data Converter is a program for converting data files in six different formats.
	<h3 id="formats">Swift formats</h3>
	<ul>
		<li><a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> (.csv)</li>
		<li><a href="http://weka.wikispaces.com/ARFF+%28stable+version%29">ARFF</a> (.arff)</li>
		<li><a href="http://www.upriss.org.uk/fca/fcafileformats.html#Burmeister">Burmaister</a> (.cxt)</li>
		<li><a href="http://www.cs.washington.edu/dm/vfml/appendixes/c45.htm">C4.5</a> (.data)</li>
		<li><a href="http://fcalgs.sourceforge.net/format.html">FIMI</a> (.dat)</li>
		<li>DTL (.dtl)</li>
	</ul>
	All accepted formats are text and can be converted with each other, it means 36 possible conversions. Swift is focused on working with a table data where rows represent objects (instances) and columns their attributes (properties). Beside the data conversion, program supports also:
	<ul>
		<li><b>Filtering</b> - changing column order, changing columns occurrences, skipping columns and rows.</li>
		<li><b>Scaling</b>  - necessary for conversion multivalent formats (such as CSV, ARFF, C4.5) to bivalent formats (such as Burmeister, FIMI, DTL), but can be used for any converssion.</li>
		<li><b>Analyzing</b> - produces statistics of data.</li>
		<li><b>Preview</b> of data parts.</li>
	</ul>
	All operations work with data of any size, only limitation is a space of hard drive (not RAM).

	<p>
	Swift provides Command-line interface (swift-cli.py) and also Graphical user interface (swift.py), which is described in a seperate <a href="#gui">GUI Manual</a> section. For quick use without useless reading, go to <a href="#tips">tips and tricks</a> section which contains examples of common use cases.
	</p>
	<h3>Positional arguments</h3>
	<dl>
		<dt><b>source</b></dt>
		<dd>
		The name of the file (program reads and processes this file) in one of the <a href="#formats">swift formats</a>. The <i>source</i> must ends with one of the extenssion mentioned in the list of <a href="#formats">swift formats</a> or the optional <i>--source_format</i> argument must be used. If the <i>source</i> is ommited or if it equals to "-", the program reads the input from the <i>stdin</i>.
		</dd>
	</dl>
	<h3>Optional arguments</h3>
	<dl>
		<dt><b>-h, --help</b></dt>
		<dd>Print the help message to the <i>stdout</i> and exit.<p></p></dd>

		<dt><b>-t</b> target, <b>--target</b> target</dt>
		<dd>
		The name of the file (program writes to this file) in one of the <a href="#formats">swift formats</a>. The <i>--target</i> must ends with one of the extenssion mentioned in the list of <a href="#formats">swift formats</a> or the optional <i>--target_format</i> argument must be used. If the <i>--target</i> is omitted or if it equals to "-", the program writes the input to the <i>stdout</i>.
		<p></p>
		</dd>

		<dt><b>-ta </b>target_attributes, <b>--target_attributes</b> target_attributes</dt>
		<dd>
		The list of formulas seperated by ";",
		<pre><code>
			formulas ::= formula | (formula ";" formulas)
		</code></pre>
		where formula is the definition of attribute in the target file. The formula is of the form:
		<pre><code>
			formula ::= (new-names "=")? old-names ((":" type ("[" scale "]")?) | "[]")?
		</code></pre>
		<u>The first part</u> of the formula:
		<pre><code>
			(new-names "=")? old-names
		</code></pre>
		where new-names and old-names are the lists of names seperated by ",":
		<pre><code>
			names ::= name | (name "," names)
		</code></pre>
		where name is the word or the interval:
		<pre><code>
			name ::= \w+ | ((\d+)? "-" (\d+)?) | "*"
		</code></pre>
		has the following meaning: old-names refer to attributes in the source file by using their names (if are available) or indexes. New-names define new names of attributes used in the target file. If new-names are omitted, attributes in the target file have the same names as in the source file. New-names and old-names must have the same length, otherwise error is produced.
		<p>
		The interval determines range of indexes. If the lower bound is omitted, indexes range is from zero to upper bound. If the upper bound is omitted, indexes range is from lower bound to the maximum index of attribute in the target file. If both upper and lower bounds are omitted, indexes range is from zero to the maximum index of the attribute in the source file (for this case has been added alis "*", which has the same meaning as "-").
		</p>
		Examples (seven attributes in source file):
		<table>
			<tr><td>
			<code>4-6 produces: 4, 5, 6</code>
			</td></tr>

			<tr><td>
			<code>-5 produces: 0, 1, 2, 3, 4, 5</code>
			</td></tr>

			<tr><td>
			<code>4- produces: 4, 5, 6, 7</code>
			</td></tr>

			<tr><td>
			<code>- produces: 0, 1, 2, 3, 4, 5, 6, 7</code>
			</td></tr>

			<tr><td>
			<code>* produces: 0, 1, 2, 3, 4, 5, 6, 7</code>
			</td></tr>
		</table>
		<p><u>The second optional part</u> of the formula</p>
		<pre><code>
			((":" type ("[" scale "]")?) | "[]")?
		</code></pre>
		is composed of the attribute type,
		<pre><code>
			type ::= "n" | "e" | "s" | ("d" ("/" date_format)?)
			date_format ::= "F="? "'" .+ "'"
		</code></pre>
		where characters are aliases of data types:
		<ul>
			<li>n = numeric - all real numbers</li>
			<li>e = enumeration - finite set of named values</li>
			<li>s = string - word</li>
			<li>d = date - the default date format is ISO-8601 which combines date and time: YYYY-MM-DDThh:mm:ss. For using different date formats must be used <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">python format codes</a>,</li>
		</ul>
		<p>optional definition of the scale and the <a href="#unpack">binary unpacking</a>.</p>
		<pre><code>
			scale ::= num_scale | enum_scale | str_scale | date_scale | bin_vals
		</code></pre>
		The scale is an expression which is evaluated with a value of the attribute. Result of evaluation is True or False represented as 0 and 1.
		<p>In the <i>numeric scale</i>,</p>
		<pre><code>
			num_scale ::= (var op num_val) | (num_val op var) | (num_val op var op num_val)
		</code></pre>
		the numeric value is of the form:
		<pre><code>
			num_val ::= int ("." number?)? ("e" int)?
			int ::= ("+" | "-")? \d+
		</code></pre>
		Examples of numeric value: <code>5, -10, +47, 2.46, -2.31, +98.31, -78.4e-48, 3e8</code>
		<pre><code>
			var ::= [a-zA-Z_]+
		</code></pre>
		Variables (the form above) represent the current value of the scale evaluation and operations have the same meaning as in many programing languages such as C or Python.
		<pre><code>
			op ::= "<" | ">" | "<=" | ">=" | "==" | "!="
		</code></pre>
		Examples of numeric scales (variable is x): <code>x!=10.3, -5<=x<=10, 50==x </code>
		<p>The <i>enumeration scale</i></p>
		<pre><code>
			enum_scale ::= "'" \w+ "'"
		</code></pre>
		is the one of the value of enumeration, which must be quoted. If the value of the attribute is the exactly same as the scale, the result of the scaling is True, otherwise False.
		<p>The <i>string scale</i></p>
		<pre><code>
			str_scale ::= "'" .+ "'"
		</code></pre>
		is a quoted <a href="https://docs.python.org/2/library/re.html"> python regular expression</a>. If the regular expression matches any substring of the scaled value, result of scaling is True, otherwise False.
		<p>Example of the string scale: <code>"foo[+-*]*bar"</code>, which matches "hellfoobar", "foo--barxyz" ... but doesn't match "foo/bar" ...</p>
		<p>The <i>date scale</i></p>
		<pre><code>
			date_scale ::= ((var op date_val) | (date_val op var) | (date_val op var op date_val))
		</code></pre>
		is the exactly same expression as numeric scale, but values must be dates in valid date format.
		<p>The <i>binary values</i></p>
		<pre><code>
			bin_vals ::= ("0="? "'" .* "'" ",")? "1="? "'" .+ "'"
		</code></pre>
		allow to define new <i>binary values</i> for some bivalent attribute. The default values are 1 (True) and 0 (False). This can be useful for the conversion from multivalent format (which contains bivalent attribute, but values are different from 0 and 1) to bivalent format, without useless scaling (because values are bivalent already). Note that, this way is semantically the same as using enumeration for bivalent attribute, but use of <i>binary values</i> is prefered because is more time-efficient.
		<p id="unpack">
		The alternative to the scale is the <i>binary unpacking</i> (the total binarization) of the attribute, which can be used by "[]", writed just behind the names. This creates new attribute for every single value of the old attribute. Every new attribute is ot type enumeration with the scale: value. The order of new attributes is the same as the order of values in template attribute. If <i>binary unpacking</i> is used for more attributes, for example for two attribites, then every new attribute of the first old attribute has lower index then any of new attribute of the second old attribute.
		</p>
		<p>Example - <i>binary unpacking</i> of two attributes:</p>
		<table>
			<tr>
				<td>input
<pre>
a x
b y
b z
a x
c y
</pre>
				</td>
				<td></td>
				<td>output
<pre>
1 0 0  1 0 0
0 1 0  0 1 0
0 1 0  0 0 1
1 0 0  1 0 0
0 0 1  0 1 0
</pre>
				</td>
			</tr>
		</table>
		<p>Complete grammar of the <i>--target_attributes</i> argument:</p>
		<pre><code>
			formulas ::= formula | (formula ";" formulas)
			formula ::= (names "=")? names ((":" type ("[" scale "]")?) | "[]")?
			names ::= name | (name "," names)
			type ::= "n" | "e" | "s" | ("d" ("/" date_format)?)
			scale ::= num_scale | enum_scale | str_scale | date_scale | bin_vals
			name ::= \w+ | ((\d+)? "-" (\d+)?) | "*"
			date_format ::= "F="? "'" .+ "'"
			num_scale ::= (var op num_val) | (num_val op var) |
			              (num_val op var op num_val)
			enum_scale ::= "'" \w+ "'"
			str_scale ::= "'" .+ "'"
			date_scale ::= ((var op date_val) | (date_val op var) |
			                (date_val op var op date_val))
			bin_vals ::= ("0="? "'" .* "'" ",")? "1="? "'" .+ "'"
			var ::= [a-zA-Z_]+
			op ::= "<" | ">" | "<=" | ">=" | "==" | "!="
			date_val ::= "'" .+ "'"
			num_val ::= int ("." number?)? ("e" int)?
			int ::= ("+" | "-")? \d+
		</code></pre>
		If the <i>--target_attributes</i> argument is omitted, all attributes readed from the <i>source</i> are processed.
		<p></p>
		</dd>

		<dt><b>-c</b> [rows_count], <b>--convert</b> [rows_count]</dt>
		<dd>
			Converts the <i>source</i> to the <i>--target</i>. The optional argument rows_count defines how many rows of data should be processed.
		<p></p>
		</dd>

		<dt><b>-p</b> [rows_count], <b>--preview</b> [rows_count]</dt>
		<dd>Prints desired count of rows from the <i>source</i> table data in to the <i>stdout</i>. The default amount of printed rows is 20, but this value can be changed by using the optional argument rows_count.
		<p></p>
		</dd>

		<dt><b>-i, --info</b></dt>
		<dd>
		Prints the statistics of the <i>source</i> and for its each processed attribute. Statistics is of the form:
		<pre>
			Relation name:
			Objects count:
			Attributes count:
			====================

			name:
			index:
			type: string/enumeration
			values appearance:
			    value: occurences-count/total-count = %
				.
				.
				.

			name:
			index:
			type: numeric/date
			max: , min:
			values appearance:
			    value: occurences-count/total-count = %
				.
				.
				.

			.
			.
			.
		</pre>
		The <i>--info</i> may be used as single action (the statistics is printed to the <i>stdout</i>) or in parallel with the conversion (if <i>--target</i> is <i>stdout</i>, the new file named same as the <i>source</i>, but with extenssion .info is produced). The usage <i>--info</i> in parallel with conversion is useful for the saving time if both actions are required.
		<p></p>
		</dd>

		<dt></dt>
		<dd>
		<p></p>
		</dd>
	</dl>

	<h2 id="tips">TIPS AND TRICKS</h2>
	<h2 id="gui">GUI MANUAL</h2>
</body>
</html>
