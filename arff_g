#!/bin/python3

from pyparsing import (OneOrMore, Word, Forward, delimitedList, Literal, printables,
                       restOfLine, CharsNotIn, Optional, Suppress, quotedString, removeQuotes,
                       ZeroOrMore, CaselessLiteral, Group, lineno)

"""
from swift_fca.source_swift.parser_fca import ArffParser

with open('tests/arff/test.arff', 'r') as f:
    header_to_parse = ''
    for line in f:
        header_to_parse += line
        if line.strip() == '@data':
            break

parser = ArffParser()
parser.parse(header_to_parse)
parser.show_result()
"""

"""
<header> ::= <relation_part> <attributes_part> <data_part>
<relation_part> ::= <comment_line>* <relation> "\n" <comment_line>*
<attributes_part> ::= (<attributes_line> "\n")+
<data_part> ::= "@data"
<attributes_line> ::= <comment> | <attribute> | <blank>
<attribute> ::= "@attribute" <string> <type>
<type> ::= "numeric" | "string" | <nominal> | <date> | <relational>
<nominal> ::= "{" <string> | ("," <string>)* "}"
<date> ::= 'date' <string>?
<relational> ::= "relational" "\n" <attributes_part> "@end" <string>
<relation> ::= "@relation" <string>?
<string> ::= [^%,{}]+ | "'" .+ "'"
<blank> ::= ^$
<comment> ::= "%".*
<comment_line> ::= <comment> "\n"

"""


class Attribute():
    def __init__(self, attr_type, attr_name):
        self.type = attr_type
        self.name = attr_name
        self.children = []

    def has_children(self):
        return bool(self.children)


def show_children(attrs, parent_name=""):
    for attr in attrs:
        name = ".".join([parent_name, attr.name])
        if attr.has_children():
            show_children(attr.children, name)
        else:
            print("{}, {}".format(name, attr.type))


def parse_attribute(string, pos, tokens):
    print(tokens)
    attr = Attribute(tokens.attr_type, tokens.attr_name)
    if attr.type == "relational":
        attr.children = tokens.children
    return attr


def adapt_date_format(tokens):
    date_format = tokens.date_format.strip()
    if not date_format:
        date_format = '%Y-%m-%d'
    return {'date_format': date_format}


comment = Suppress(Literal("%") + restOfLine)
quoted = quotedString.copy().setParseAction(removeQuotes)
string = quoted | Word(printables,  excludeChars='{},%')
relation = Suppress(CaselessLiteral("@relation")) + Optional(string, default='default_name')('rel_name')
relation_part = ZeroOrMore(comment) + relation + ZeroOrMore(comment)
nominal = (Suppress(Literal("{")) + Group(delimitedList(string)) + Suppress(Literal("}")))
nominal.setParseAction(lambda t: 'g')
date = CaselessLiteral("date") + Optional(CharsNotIn("{},\n"))("next_arg").setParseAction(adapt_date_format)
attributes_part = Forward()
relational = CaselessLiteral("relational") + attributes_part + Suppress(CaselessLiteral("@end")) + string
attr_type = (CaselessLiteral("numeric") | CaselessLiteral("string") | nominal | date | relational)("attr_type")
attribute = Suppress(CaselessLiteral("@attribute")) + (string.copy())("attr_name") + attr_type
attribute_line = comment | attribute
attributes_part << (Group(OneOrMore(attribute_line)))("children")
data_part = (CaselessLiteral("@data"))("data_start").setParseAction(lambda s, p, k: (lineno(p, s)))
arff_header = relation_part + attributes_part + data_part
attribute.setParseAction(parse_attribute)

with open('ignore/ignore.g.arff', 'r') as f:
    header_to_parse = ''
    for line in f:
        header_to_parse += line
        if line.strip() == '@data':
            break
    result = arff_header.parseString(header_to_parse)

print("Relation: ", result.rel_name)
show_children(result.children)
print(result.data_start)
